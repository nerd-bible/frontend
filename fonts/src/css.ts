type CSSFace = {
	name: string;
	style: string;
	postscript: string;
	weight: string;
	unicodeRange: string;
	path: string;
};
const cssFaces: CSSFace[] = [];

// function getFace(bytes: Uint8Array): CSSFace {
// 	// weights
// 	let weightMin: number | undefined;
// 	let weightMax: number | undefined;
// 	const weightClasses: Record<string, number> = (parsed as any).usWeightClasses;
// 	for (const wname in weightClasses) {
// 		const n = weightClasses[wname];
// 		if (!weightMin || n < weightMin) weightMin = n;
// 		if (!weightMax || n > weightMax) weightMax = n;
// 	}
// 	// range gathering
// 	let unicodeRange = "";
// 	const codepoints: number[] = [];
// 	for (let i = 0; i < parsed.glyphs.length; i++) {
// 		const g = parsed.glyphs.get(i);
// 		for (const cp of g.unicodes) codepoints.push(cp);
// 	}
// 	codepoints.sort((a, b) => a - b);
// 	// range finding
// 	const fmtN = (n: number) => n.toString(16).padStart(4, "0").toUpperCase();
// 	let start = codepoints[0];
// 	const isPrintable = /[^\p{C}]$/u;
// 	const delimeter = ", ";
// 	for (let i = 1; i < codepoints.length; i++) {
// 		const end = codepoints[i - 1];
// 		if (
// 			end + 1 !== codepoints[i] &&
// 			isPrintable.test(String.fromCodePoint(end))
// 		) {
// 			unicodeRange +=
// 				end === start ? `U${fmtN(start)}` : `U+${fmtN(start)}-${fmtN(end)}`;
// 			unicodeRange += delimeter;
// 			start = codepoints[i];
// 		}
// 	}
//
// 	return {
// 		name: parsed.names.fontFamily["en"],
// 		style: parsed.names.fontSubfamily["en"],
// 		postscript: parsed.names.postScriptName["en"],
// 		weight: `${weightMin} ${weightMax}`,
// 		unicodeRange: unicodeRange.substring(
// 			0,
// 			unicodeRange.length - delimeter.length,
// 		),
// 		path,
// 	};
// }

// console.log("wrote", cssFaces.length, "fonts to", fontPath);
// console.log("wrote", cssPath);

// Get info for CSS @font-face
// const parsed = create(buffer.buffer) as Font;
// if (fontName.startsWith("base")) {
// 	for (const [s, ranges] of Object.entries(subsets)) {
// 		const subset = makeSubset(parsed, ranges);
// 		const outPath = `${prefix}.${s}.woff2`;
//
// 		const face = getFace(subset, outPath);
// 		cssFaces.push(face);
//
// 		toWoff2(subset, outPath);
// 	}
// } else {
// }

// writeFileSync(
// 	cssOutPath,
// 	fontFaces.reduce((acc, face) => {
// 		const regularName = face.postscript.endsWith("-Regular")
// 			? `, local('${face.postscript.replace("-Regular", "")}')`
// 			: "";
// 		acc += `
//
// @font-face {
// 	font-family: '${face.name}';
// 	font-style: ${face.style.toLowerCase()};
// 	font-weight: ${face.weight};
// 	font-display: swap;
// 	src: local('${face.postscript}')${regularName}, url('/${face.path}') format('woff2');
// 	unicode-range: ${face.unicodeRange};
// }`;
// 		return acc;
// 	}, "/** Autogenerated by download-fonts.ts */"),
// );
// console.log("wrote", fontFaces.length, "faces to", cssOutPath);
